
“ут вз€л полезную идею дл€ алгоритма
http://citforum.ru/programming/theory/alg_triangl/index.shtml#:~:text=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82%20%D0%BF%D1%83%D1%82%D0%B5%D0%BC%20%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BD%D0%B0%D1%80%D0%B0%D1%89%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F,%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%BA%20%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B5%20%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B5%D0%B9%20%D1%82%D1%80%D0%B8%D0%B0%D0%BD%D0%B3%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D0%B8.

ќписание работы алгоритма FillEngine.FillPoligonByTriangles

¬водна€ информаци€:
ѕредполагаем, что наш полигон левый, т.е. внутренн€€ область полигона находитс€ слева по началу движени€.
„ерез любые 2 точки мы можем провести линию
” нас есть функци€, котора€ вернет дистанцию до этой линии со знаком, в зависимости от того точка находитс€ слева от линии, либо справа

Ѕудем разбивать весь полигон на выпуклые полигоны

¬озьмем первые 3 точки полигона и будем их двигать по кругу полигона до тех пор, пока последн€€ точка лежит слева от пр€мой образованой 2м€ предыдущими точками.
 ак только это условие нарушаетс€ - мы находим край вогнутости полигона.
‘иксируем 2 последние точки вошедшие в выпуклую часть полигона и двигаем одну точку в обратном направлении от данных 2х. 
ѕровер€ем, что это точка, также всегда находитс€ слева от пр€мой образованной найденными последними 2м€ точками.
 ак только условие левосторонности нарушаетс€, мы находим начало выпуклого полигона.
—охран€ем выпуклый полигон и вырезаем его из общего полигона.
ѕродолжаем движение по кругу повтор€€ алгоритм.
¬ итоге получаем список выпуклых полигонов.

Ћюбое разбиение выпуклого полигона на треугольники будет верным. 
Ќайдем вершину, котора€ минимально удалена от противоположной ей вершины.
ѕостроим к ней пр€мые от остальных вершин - это решение дл€ одного выпуклого полигона.

—ложим все решени€ - это и есть наш результат

