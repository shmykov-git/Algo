<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
        <script type="importmap">
            {
              "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
                "OrbitControls": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/controls/OrbitControls.js",
                "cannon": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
              }
            }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'OrbitControls'
        import * as CANNON from 'cannon'

        // Approximate world size [30, 30, 30]

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // Gravity pointing downwards

        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1)
        scene.add(ambientLight)

        const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1)
        directionalLight.position.set(-5, -5, 5)
        scene.add(directionalLight)


        // const groundCannotMaterial = new CANNON.Material('ground');
        // // Create a ground plane
        // const groundBody = new CANNON.Body({
        //     mass: 0, // Static body
        //     shape: new CANNON.Plane(),
        // });
        // groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to be horizontal
        // world.addBody(groundBody);
        // groundBody.material = groundCannotMaterial;

        // const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x008800, wireframe: false });
        // const groundGeometry = new THREE.PlaneGeometry(30, 30, 10, 10);
        // const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        // groundMesh.rotation.x = -Math.PI / 2;
        // scene.add(groundMesh);

        // физический материал для всех Polyhedron
        const pPolyhedronMaterial = new CANNON.Material('Polyhedron');

        // все Polyhedron одинакого взаимодействуют друг с другом
        const contactPolyhedronMaterial = new CANNON.ContactMaterial(pPolyhedronMaterial, pPolyhedronMaterial, {
            friction: 0.5, // Коэффициент трения
            restitution: 0.7, // Коэффициент упругости
        });
        world.addContactMaterial(contactPolyhedronMaterial);  

        // физический материал для всех шаров сцены
        const pSphereMaterial = new CANNON.Material('sphere');
        
        // все Sphere одинакого взаимодействуют друг с другом
        const contactSphereMaterial = new CANNON.ContactMaterial(pSphereMaterial, pSphereMaterial, {
            friction: 0.5, // Коэффициент трения
            restitution: 0.7, // Коэффициент упругости
        });
        world.addContactMaterial(contactSphereMaterial);  

        // все Sphere одинакого взаимодействуют с Polyhedron
        const contactSpherePolyhedronMaterial = new CANNON.ContactMaterial(pSphereMaterial, pPolyhedronMaterial, {
            friction: 0.5, // Коэффициент трения
            restitution: 0.7, // Коэффициент упругости
        });
        world.addContactMaterial(contactSpherePolyhedronMaterial);  


        class PObject {
            constructor(args, pShapes, mesh) {
                // Создание физического тела

                this.bodies = pShapes.map(shape => new CANNON.Body({
                    mass: args.mass / pShapes.length, // Масса объекта
                    position: new CANNON.Vec3(...args.position), // Начальная позиция
                    shape: shape
                }));

                this.body = this.bodies[0];

                // Добавление тела в мир
                this.bodies.forEach(body => {
                    if (args.static)
                        body.type = CANNON.Body.STATIC // Устанавливаем тип статического тела

                    body.material = args.pMaterial;
                    body.angularDamping = 0.5; // Damping to reduce spinning over time
                    world.addBody(body);                    
                });

                // Добавляем изображение на сцену
                this.mesh = mesh;
                scene.add(mesh);
            }

            update() {
                if (this.bodies.length > 1)
                    return;
                
                let p = this.body.position;
                let q = this.body.quaternion;
                // меняем позицию mesh в соответствии с world body
                this.mesh.position.set(p.x, p.y, p.z);
                // вращаем mesh в соответствии с вращением world body
                this.mesh.quaternion.set(q.x, q.y, q.z, q.w);
            }            
        }

        class PPolyhedron extends PObject {
            constructor(args) {
                // структура faces: [[],[]... (l), [],[]... (l)]
                var l = args.faces.length / 2;
                var bodiesFaces = [...Array(l/2).keys().map(i => [args.faces[2*i], args.faces[2*i+1], args.faces[2*i+l], args.faces[2*i+1+l]])];

                // Создаем многогранник (Polyhedron) в мире
                // todo: скопировал первую точку во все точки, которых нет в faces
                var pShapes = bodiesFaces.map(bFaces => new CANNON.ConvexPolyhedron({
                    vertices: args.vertices.map((p, i) => bFaces.flatMap(k=>k).some(k => k == i) ? p : args.vertices[bFaces[0][0]]).map(p => new CANNON.Vec3(...p)),
                    faces: bFaces
                }));

                // Создаем представление многогранника на сцене
                const gVertices = new Float32Array(args.vertices.flatMap(v => v))
                const gIndices = new Uint16Array(args.faces.flatMap(fs => fs.flatMap(i => i)))
                const geometry = new THREE.BufferGeometry()
                geometry.setAttribute('position', new THREE.BufferAttribute(gVertices, 3))
                geometry.setIndex(new THREE.BufferAttribute(gIndices, 1))
                const material = new THREE.MeshStandardMaterial({ color: args.color, flatShading: false, opacity: 0.2, transparent: true });
                const mesh = new THREE.Mesh(geometry, material);

                super(args, pShapes, mesh)
            }
        }

        // Class to handle physics and visual representation of shpere
        class PShere extends PObject {
            constructor(args) {
                // Create physics body
                const pShape = new CANNON.Sphere(args.radius);
 
                // Create visual representation
                const geometry = new THREE.IcosahedronGeometry(args.radius, 2);
                const material = new THREE.MeshBasicMaterial({ color: args.color, wireframe: true });
                const mesh = new THREE.Mesh(geometry, material);

                super(args, [pShape], mesh)
            }
        }

        function inverseFaces(faces) {
            return faces.map(f => [f[0], f[2], f[1]])
        }

        function multPoints(mult, points) {
            return points.map(p => [mult * p[0], mult * p[1], mult * p[2]])
        }

        function addPoints(v, points) {
            return points.map(p => [v + p[0], v + p[1], v + p[2]])
        }
        
        // <generated spheres/>

        // Create multiple objects
        const objects = [
            // new PPolyhedron(
            //     addPoints(-3, multPoints(6, [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]])), 
            //     [[0, 1, 2], [0, 2, 3], [4, 5, 6], [4, 6, 7], [0, 1, 5], [0, 5, 4], [1, 2, 6], [1, 6, 5], [2, 3, 7], [2, 7, 6], [3, 0, 4], [3, 4, 7]], 
            //     100, [0, 20, 0], 0xffff00),
            new PPolyhedron({
                vertices: [[-10,-10,-10],[10,-10,-10],[10,10,-10],[-10,10,-10],[-10,-10,10],[10,-10,10],[10,10,10],[-10,10,10],[-9.5,-9.5,-9.5],[9.5,-9.5,-9.5],[9.5,9.5,-9.5],[-9.5,9.5,-9.5],[-9.5,-9.5,9.5],[9.5,-9.5,9.5],[9.5,9.5,9.5],[-9.5,9.5,9.5]],
                faces: [[0,3,2],[0,2,1],[0,1,5],[0,5,4],[0,4,7],[0,7,3],[6,5,1],[6,1,2],[6,2,3],[6,3,7],[6,7,4],[6,4,5],[9,10,11],[9,11,8],[12,13,9],[12,9,8],[11,15,12],[11,12,8],[10,9,13],[10,13,14],[15,11,10],[15,10,14],[13,12,15],[13,15,14]],
                mass: 0,
                static: true,
                position: [0, 0, 0],
                color: 0xffff00,
                pMaterial: pPolyhedronMaterial,
            }),
            new PShere({ radius: 1, mass: 1, position: [0, 0, 0], color: 0xff0000, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [0, 2, 0.5], color: 0x00ff00, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [-1, 8, 0], color: 0x0000ff, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [0, 7, 1], color: 0xff0000, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [1, 3, -1], color: 0x00ff00, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [-1, 5, -1], color: 0x0000ff, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [0, 0, 0], color: 0xff0000, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [0, 2, 0.5], color: 0x00ff00, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [-1, 8, 0], color: 0x0000ff, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [0, 7, 1], color: 0xff0000, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [1, 3, -1], color: 0x00ff00, pMaterial: pSphereMaterial}),
            new PShere({ radius: 1, mass: 1, position: [-1, 5, -1], color: 0x0000ff, pMaterial: pSphereMaterial}),
            new PShere({ radius: 3, mass: 113, position: [0, 6, 0], color: 0x2266cc, pMaterial: pSphereMaterial}),
        ];

        // Set camera position
        camera.position.z = 35;
        camera.position.y = 20;
        camera.lookAt(0, 0, 0);        

        // возможность вращать сцену
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 1
        controls.screenSpacePanning = false
        controls.minDistance = 0.1
        controls.maxDistance = 50
        // // Убираем ограничения по горизонтальному углу
        // controls.minAzimuthAngle = -Infinity; // Без ограничений
        // controls.maxAzimuthAngle = Infinity;  // Без ограничений
        // // Убираем ограничения по вертикальному углу
        // controls.minPolarAngle = 0; // Минимальный угол (0 радиан)
        // controls.maxPolarAngle = Math.PI; // Максимальный угол (Math.PI радиан)        

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Step the physics world
            world.step(1 / 60);

            // Sync Three.js mesh with Cannon.js body
            objects.forEach(obj => obj.update());
            controls.update()
            // updateCameraUp()
            updateGravity()
            // Render the scene
            renderer.render(scene, camera);
        }

        animate();

        function getOrtDown(a, b) {
            const ab = new THREE.Vector3();
            ab.copy(b).cross(a);
            const aba = new THREE.Vector3();
            aba.copy(ab).cross(a);
            return aba.normalize();
        }

        function updateCameraUp() {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // Получаем направление камеры
            const up = getOrtDown(direction, camera.up).multiplyScalar(-1)
            camera.up.set(up.x, up.y, up.z)
        }

        function updateGravity() {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // Получаем направление камеры
            const gravity = getOrtDown(direction, camera.up).multiplyScalar(9.8)
            world.gravity.set(gravity.x, gravity.y, gravity.z)
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
